"""
Diagram Processing Module
Extracts and processes chess diagram markers from synthesized text
"""

import re
import uuid
import chess
import chess.svg
from chess_positions import parse_moves_to_fen

def extract_fen_from_marker(marker_content):
    """Extract FEN string from diagram marker content."""
    # FEN pattern: 8 ranks separated by /, followed by color, castling, etc.
    fen_pattern = r'([rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}\s+[wb]\s+[-KQkq]+\s+[-a-h0-8]+\s+\d+\s+\d+)'
    match = re.search(fen_pattern, marker_content)
    if match:
        return match.group(1).strip()
    return None

def extract_moves_from_description(description):
    """
    Extract move sequence from diagram description.
    Handles:
    - Multiple sequences with 'OR' (takes first sequence)
    - Move annotations like '!', '?', '!!', '!?', '?!'
    """
    # Handle 'OR' - split and take first valid move sequence
    if ' OR ' in description.upper():
        parts = re.split(r'\s+OR\s+', description, flags=re.IGNORECASE)
        for part in parts:
            # Try each part until we find valid moves
            result = _extract_single_sequence(part)
            if result:
                return result
        return None

    return _extract_single_sequence(description)

def _extract_single_sequence(text):
    """Extract a single move sequence, stripping annotations."""
    # Remove move annotations: !, ?, !!, !?, ?!
    cleaned = re.sub(r'[!?]+', '', text)

    # Extract move sequence
    moves_match = re.search(r'[1-9]\.[a-zA-Z0-9\s\.\-\+#=]+', cleaned)
    if moves_match:
        return moves_match.group(0).strip()
    return None

def generate_svg_from_fen(fen):
    """Generate SVG diagram from FEN string."""
    try:
        board = chess.Board(fen)
        svg = chess.svg.board(board, size=390)
        return svg
    except Exception as e:
        print(f"Warning: Could not generate SVG for FEN '{fen}': {e}")
        return None

def extract_diagram_markers(text):
    """
    Extract all diagram markers from text and generate SVG.
    Handles both FEN strings and move sequences.
    NEW: Supports caption format [DIAGRAM: <position> | Caption: <description>]
    Returns list of diagram objects with id, fen, svg, and caption.
    """
    pattern = r'\[DIAGRAM:\s*([^\]]+)\]'
    matches = re.findall(pattern, text)

    diagram_positions = []
    for match in matches:
        fen = None
        caption = None
        position_part = match  # Default to full match

        # NEW: Check for caption separator (|)
        if '|' in match:
            parts = match.split('|', 1)
            position_part = parts[0].strip()

            # Extract caption text after "Caption:" label
            caption_part = parts[1].strip()
            if caption_part.lower().startswith('caption:'):
                caption = caption_part[8:].strip()  # Remove "Caption:" prefix
            else:
                caption = caption_part  # Use as-is if no "Caption:" label

            print(f"[extract_diagram_markers] Found caption: {caption}")

        # Strategy 1: Try to extract FEN string directly from position part
        fen = extract_fen_from_marker(position_part)

        if fen:
            # FEN found - use extracted caption, or fallback to moves
            if not caption:
                moves = extract_moves_from_description(position_part)
                caption = moves if moves else f"Position: {fen[:20]}..."
        else:
            # Strategy 2: No FEN, try to extract and parse move sequence
            moves = extract_moves_from_description(position_part)

            if moves:
                # Try to convert moves to FEN
                print(f"[extract_diagram_markers] Parsing moves: {moves}")
                fen = parse_moves_to_fen(moves)

                if fen:
                    # Use extracted caption, or fallback to moves
                    if not caption:
                        caption = moves
                    print(f"[extract_diagram_markers] Successfully parsed moves to FEN")
                else:
                    print(f"[extract_diagram_markers] Failed to parse moves: {moves}")

        # If we got a FEN (from either strategy), generate SVG
        if fen:
            svg = generate_svg_from_fen(fen)

            if svg:
                diagram_positions.append({
                    'fen': fen,
                    'svg': svg,
                    'caption': caption or f"Position: {fen[:20]}...",
                    'original_marker': f'[DIAGRAM: {match}]'
                })
            else:
                print(f"[extract_diagram_markers] Failed to generate SVG for FEN: {fen}")
        else:
            print(f"[extract_diagram_markers] No FEN or moves found in marker: {match[:50]}")

    return diagram_positions

def replace_markers_with_ids(text, diagram_positions):
    """
    Replace diagram markers with UUID placeholders.
    NON-DESTRUCTIVE: Uses re.sub with specific patterns.
    """
    result = text
    
    for diagram in diagram_positions:
        diagram_id = str(uuid.uuid4())
        diagram['id'] = diagram_id
        
        # Replace specific marker, not greedy
        original_marker = re.escape(diagram['original_marker'])
        result = re.sub(
            original_marker,
            f'[DIAGRAM_ID:{diagram_id}]',
            result,
            count=1
        )
    
    return result

def wrap_bare_fens(text):
    """
    POST-PROCESSING: Wrap any bare FEN strings that slipped through.
    Catches FENs that aren't already in [DIAGRAM: ...] brackets.
    """
    # FEN pattern: 8 ranks separated by /, followed by color, castling, etc.
    # Simple pattern without problematic variable-width lookbehind
    fen_pattern = r'([rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}/[rnbqkpRNBQKP1-8]{1,8}\s+[wb]\s+[-KQkq]+\s+[-a-h0-8]+\s+\d+\s+\d+)'

    def wrap_match(match):
        fen = match.group(1)
        # Check if already wrapped by looking at preceding text
        start_pos = match.start()
        # Get preceding 20 characters
        preceding = text[max(0, start_pos - 20):start_pos]
        # If we find [DIAGRAM: in the preceding text, don't wrap again
        if '[DIAGRAM:' in preceding:
            return fen  # Return unchanged
        else:
            return f'[DIAGRAM: {fen}]'  # Wrap it

    return re.sub(fen_pattern, wrap_match, text)

